#!/usr/bin/python

# Original author:
__author__      = "Riccardo Mutschlechner <riccardo@cs.wisc.edu>, John Detter <jdetter@wisc.edu>"
# Edited by Isaac Klop <isaac.klop@os3.nl>
# Script used to perform calculations on data generated by entropy_main.py:
# 		https://github.com/Ricky54326/CS736-ASLR-Benchmarks


import argparse
import cPickle as pickle
import numpy as np
from pyentrp import entropy as ent
import matplotlib.mlab as mlab
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
from bitstring import BitArray

def getStackBits(addr):
	return bitfield(addr)[11:43]

def getHeapBits(addr):
	return bitfield(addr)[3:35]

def graph(data,filename):
	x = []
	y = []
	for addr in data:
		#b = BitArray(getStackBits(addr))
		b = BitArray(getHeapBits(addr))
		x.append(b[16:].uint)
		y.append(b[:16].uint)

	plt.figure(figsize=(20,20))
	plt.scatter(x,y,s=0.1,marker=".",c="k")
	plt.title('Scatterplot of used memory addresses', fontsize=25)
	plt.xlabel('lower order 16 bits', fontsize=25)
 	plt.ylabel('higher order 16 bits', fontsize=25)
	axes = plt.gca()
	axes.tick_params(axis='both',labelsize=25)
	axes.get_xaxis().set_major_formatter(ticker.FormatStrFormatter("%x"))
	axes.get_yaxis().set_major_formatter(ticker.FormatStrFormatter("%x"))

	pngfile = filename+"-plot.png"
	plt.savefig(pngfile, bbox_inches="tight")
	#plt.show()

def minmax(data):
	min_data, max_data = BitArray(getHeapBits(np.min(data))), BitArray(getHeapBits(np.max(data)))
	#min_data, max_data = BitArray(getStackBits(np.min(data))), BitArray(getStackBits(np.max(data)))
	print min_data
	print max_data

def bitfield(n):
	return [int(digit) for digit in bin(n)[2:]]

def bitdistribution(data):
	array = {}
	for i in range(47):
		array[i]=0
	for addr in data:
		for i in range(47):
			array[i]+=bitfield(addr)[i]
	for i in range(47):
		print str(i)+":"+str(array[i])

if __name__ == "__main__":

	# parse CL args
	parser = argparse.ArgumentParser(description="Entropy data histogram graphing")
	parser.add_argument("-f", "--file", help="the pickled data to graph", default="data.p")
	parser.add_argument("-p", "--pickled", help="the data is pickled", default=True)
	args = vars(parser.parse_args())
	filename = args["file"]
	pickled = args["pickled"]

	if pickled:
		# load data first
		data = pickle.load(open(filename, "rb"))
	else:
		data = [int(line.strip(), 16) for line in open(filename, "rb")]
	
	minmax(data)
	#graph(data,filename)
	#bitdistribution(data)
